% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dotPlot.R
\name{dotPlot}
\alias{dotPlot}
\title{Compact plotting of per group summaries for}
\usage{
dotPlot(
  data_frame,
  x.by,
  y.by,
  color.by,
  size.by,
  scale = "none",
  split.by = NULL,
  rows.use = NULL,
  do.hover = FALSE,
  size = 6,
  min.size = 0.01,
  max.size = NA,
  legend.size.title = waiver(),
  scale_for_size = scale_size(name = legend.size.title, limits = c(min.size, max.size),
    range = c(0, size)),
  min.color = "grey90",
  max.color = "#C51B7D",
  min.value.color = NA,
  max.value.color = NA,
  legend.color.title = waiver(),
  legend.color.breaks = waiver(),
  legend.color.breaks.labels = waiver(),
  scale_for_color = scale_color_gradient(name = legend.color.title, low = min.color, high
    = max.color, limits = c(min.value.color, max.value.color), breaks =
    legend.color.breaks, labels = legend.color.breaks.labels),
  main = NULL,
  sub = NULL,
  ylab = y.by,
  y.labels = NULL,
  y.reorder = NULL,
  xlab = x.by,
  x.labels.rotate = TRUE,
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  theme = theme_classic(),
  legend.show = TRUE,
  data.out = FALSE
)
}
\arguments{
\item{data_frame}{A data_frame where columns are features and rows are observations you might wish to visualize.}

\item{x.by, y.by}{Single strings denoting the name of a column of \code{data_frame} containing numeric data to use for the x- and y-axis of the scatterplot.}

\item{color.by}{Single string denoting the name of a column of \code{data_frame} to use for the color of plotted dots.}

\item{size.by}{Single string denoting the name of a column of \code{data_frame} to use for the size plotted dots.}

\item{scale}{"none", "rows", "cols". Sets whether or not to z-score transform each row, or each column, of color-values.}

\item{split.by}{1 or 2 strings denoting the name(s) of column(s) of \code{data_frame} containing discrete data to use for faceting / separating data points into separate plots.

When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.

When 1 column is named, shape control can be achieved with \code{split.nrow} and \code{split.ncol}}

\item{rows.use}{String vector of rownames of \code{data_frame} OR an integer vector specifying the row-indices of data points which should be plotted.

Alternatively, a Logical vector, the same length as the number of rows in \code{data_frame}, where \code{TRUE} values indicate which rows to plot.}

\item{do.hover}{Logical. Default = \code{FALSE}.
If set to \code{TRUE} the ggplot output will be converted to an interactive plotly object in which underlying data for individual dots will be displayed when you hover your cursor over them.}

\item{size}{Number which sets the visual dot size associated with the highest value shown by dot size.}

\item{min.size, max.size}{Numbers, representing after summarization size values, which set the bounds of the size scale.
When set to NA, the minimum/maximum of the data are used.}

\item{scale_for_size, scale_for_color}{a ggplot scale to use for color and size aesthetics. Default values are the only place that makes use of related dotPlot inputs, so if you use your own scale, you either need to write it with these inputs included, or else they will not get utilized: \itemize{
\item size, min.size, max.size, legend.size.title for \code{scale_for_size}
\item min.color, max.color, min.value.color, max.value.color, legend.color.title, legend.color.breaks, legend.color.breaks.labels for \code{scale_for_color}
}}

\item{min.color, max.color}{colors to use to represent minimum and maximum color values.
Default = light grey and purple.}

\item{min.value.color, max.value.color}{Numbers which set the values associated with the minimum and maximum colors.}

\item{legend.color.title, legend.size.title}{String or \code{NULL}, sets the title displayed above legend keys.}

\item{legend.color.breaks}{Numeric vector which sets the discrete values to label in the color-scale legend for \code{color.by}-data.}

\item{legend.color.breaks.labels}{String vector, with same length as \code{legend.color.breaks}, which sets the labels for the tick marks of the color-scale.}

\item{main}{String, sets the plot title. Default = "make" and if left as make, a title will be automatically generated.  To remove, set to \code{NULL}.}

\item{sub}{String, sets the plot subtitle.}

\item{ylab}{String which sets the y/grouping-axis label.
Default is \code{group.by} so it defaults to the name of the grouping information.
Set to \code{NULL} to remove.}

\item{y.labels}{String vector, c("label1","label2","label3",...) which overrides the names of the samples/groups.}

\item{y.reorder}{Integer vector. A sequence of numbers, from 1 to the number of groupings, for rearranging the order of groupings.

Method: Make a first plot without this input.
Then, treating the bottom-most grouping as index 1, and the top-most as index n,
values of y.reorder should be these indices, but in the order that you would like them rearranged to be.

Recommendation for advanced users: If you find yourself coming back to this input too many times, an alternative solution that can be easier long-term
is to make the target data into a factor, and to put its levels in the desired order: \code{factor(data, levels = c("level1", "level2", ...))}.
\code{\link{colLevels}} can be used to quickly get the identities that need to be part of this 'levels' input.}

\item{xlab}{String which sets the x/var-axis label.
Set to \code{NULL} to remove.}

\item{x.labels.rotate}{Logical which sets whether the var-labels should be rotated.}

\item{split.nrow, split.ncol}{Integers which set the dimensions of faceting/splitting when faceting by a single feature.}

\item{split.adjust}{A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. `list(scales = "free")`.

For options, when giving 1 column to \code{split.by}, see \code{\link[ggplot2]{facet_wrap}},
OR when giving 2 columns to \code{split.by}, see \code{\link[ggplot2]{facet_grid}}.}

\item{theme}{A ggplot theme which will be applied before internal adjustments.
Default = \code{theme_classic()}.
See \url{https://ggplot2.tidyverse.org/reference/ggtheme.html} for other options and ideas.}

\item{legend.show}{Logical. Whether the legend should be displayed. Default = \code{TRUE}.}

\item{data.out}{Logical. When set to \code{TRUE}, changes the output, from the plot alone, to a list containing the plot (\code{p}), its underlying data (\code{data}),
and the ultimately used mapping of columns to given aesthetic sets, because modification of newly made columns is required for many features ("cols_used").}
}
\description{
Compact plotting of per group summaries for
}
\author{
Daniel Bunis
}
