% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dotPlot.R
\name{dotPlotCalc}
\alias{dotPlotCalc}
\title{Compact plotting of per group summaries for expression of multiple features}
\usage{
dotPlotCalc(
  data_frame,
  vars,
  group.by,
  summary.fxn.color = mean,
  summary.fxn.size = length,
  scale = TRUE,
  split.by = NULL,
  rows.use = NULL,
  size = 6,
  min.size = 0.01,
  max.size = NA,
  legend.size.title = waiver(),
  scale_for_size = scale_size(name = legend.size.title, limits = c(min.size, max.size),
    range = c(0, size)),
  min.color = "grey90",
  max.color = "#C51B7D",
  min.value.color = NA,
  max.value.color = NA,
  legend.color.title = waiver(),
  legend.color.breaks = waiver(),
  legend.color.breaks.labels = waiver(),
  scale_for_color = scale_color_gradient(name = legend.color.title, low = min.color, high
    = max.color, limits = c(min.value.color, max.value.color), breaks =
    legend.color.breaks, labels = legend.color.breaks.labels),
  var.adjustment = NULL,
  var.adj.fxn = NULL,
  do.hover = FALSE,
  main = NULL,
  sub = NULL,
  ylab = group.by,
  y.labels = NULL,
  y.reorder = NULL,
  xlab = NULL,
  x.labels.rotate = TRUE,
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  theme = theme_classic(),
  legend.show = TRUE,
  data.out = FALSE,
  numeric.only = TRUE
)
}
\arguments{
\item{data_frame}{A data_frame where columns are features and rows are observations you might wish to visualize.}

\item{vars}{String vector denoting the names of all columns of \code{data_frame} you wish to have summarized (per group / facet) in the dotPlot.}

\item{group.by}{String representing the name of a columns of \code{data_frame} to use for separating the observations into discrete groups.}

\item{summary.fxn.color, summary.fxn.size}{A function which sets how color or size will be used to summarize \code{vars}-data within each group.
Any function can be used as long as it takes in a numeric vector and returns a single numeric value.}

\item{scale}{String which sets whether the values shown with color should be z-scored (centered and scaled) after summarization.}

\item{split.by}{1 or 2 strings denoting the name(s) of column(s) of \code{data_frame} containing discrete data to use for faceting / separating data points into separate plots.

When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.

When 1 column is named, shape control can be achieved with \code{split.nrow} and \code{split.ncol}}

\item{rows.use}{String vector of rownames of \code{data_frame} OR an integer vector specifying the row-indices of data points which should be plotted.

Alternatively, a Logical vector, the same length as the number of rows in \code{data_frame}, where \code{TRUE} values indicate which rows to plot.}

\item{size}{Number which sets the visual dot size associated with the highest value shown by dot size.}

\item{min.size, max.size}{Numbers, representing after summarization size values, which set the bounds of the size scale.
When set to NA, the minimum/maximum of the data are used.}

\item{scale_for_size, scale_for_color}{a ggplot scale to use for color and size aesthetics. Default values are the only place that makes use of related dotPlot inputs, so if you use your own scale, you either need to write it with these inputs included, or else they will not get utilized: \itemize{
\item size, min.size, max.size, legend.size.title for \code{scale_for_size}
\item min.color, max.color, min.value.color, max.value.color, legend.color.title, legend.color.breaks, legend.color.breaks.labels for \code{scale_for_color}
}}

\item{min.color, max.color}{colors to use to represent minimum and maximum color values.
Default = light grey and purple.}

\item{min.value.color, max.value.color}{Numbers which set the values associated with the minimum and maximum colors.}

\item{legend.color.title, legend.size.title}{String or \code{NULL}, sets the title displayed above legend keys.}

\item{legend.color.breaks}{Numeric vector which sets the discrete values to label in the color-scale legend for \code{color.by}-data.}

\item{legend.color.breaks.labels}{String vector, with same length as \code{legend.color.breaks}, which sets the labels for the tick marks of the color-scale.}

\item{var.adjustment}{A recognized string indicating whether the \code{var}-data should be used directly (default) or should be adjusted in the ways below prior to summarization with the \code{summary.fxn}s:
\itemize{
\item{"z-score": scaled with the scale() function to produce a relative-to-mean z-score representation}
\item{"relative.to.max": divided by the maximum expression value to give percent of max values between [0,1]}
}}

\item{var.adj.fxn}{If you wish to apply a function to edit the \code{var} data before use, in a way not possible with the \code{var.adjustment} input,
this input can be given a function which takes in a vector of values as input and returns a vector of values of the same length as output.

For example, \code{function(x) \{log2(x)\}} or \code{as.factor}.

In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.}

\item{do.hover}{Logical. Default = \code{FALSE}.
If set to \code{TRUE} the ggplot output will be converted to an interactive plotly object in which underlying data for individual dots will be displayed when you hover your cursor over them.}

\item{main}{String, sets the plot title. Default = "make" and if left as make, a title will be automatically generated.  To remove, set to \code{NULL}.}

\item{sub}{String, sets the plot subtitle.}

\item{ylab}{String which sets the y/grouping-axis label.
Default is \code{group.by} so it defaults to the name of the grouping information.
Set to \code{NULL} to remove.}

\item{y.labels}{String vector, c("label1","label2","label3",...) which overrides the names of the samples/groups.}

\item{y.reorder}{Integer vector. A sequence of numbers, from 1 to the number of groupings, for rearranging the order of groupings.

Method: Make a first plot without this input.
Then, treating the bottom-most grouping as index 1, and the top-most as index n,
values of y.reorder should be these indices, but in the order that you would like them rearranged to be.

Recommendation for advanced users: If you find yourself coming back to this input too many times, an alternative solution that can be easier long-term
is to make the target data into a factor, and to put its levels in the desired order: \code{factor(data, levels = c("level1", "level2", ...))}.
\code{\link{colLevels}} can be used to quickly get the identities that need to be part of this 'levels' input.}

\item{xlab}{String which sets the x/var-axis label.
Set to \code{NULL} to remove.}

\item{x.labels.rotate}{Logical which sets whether the var-labels should be rotated.}

\item{split.nrow, split.ncol}{Integers which set the dimensions of faceting/splitting when faceting by a single feature.}

\item{split.adjust}{A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. `list(scales = "free")`.

For options, when giving 1 column to \code{split.by}, see \code{\link[ggplot2]{facet_wrap}},
OR when giving 2 columns to \code{split.by}, see \code{\link[ggplot2]{facet_grid}}.}

\item{theme}{A ggplot theme which will be applied before internal adjustments.
Default = \code{theme_classic()}.
See \url{https://ggplot2.tidyverse.org/reference/ggtheme.html} for other options and ideas.}

\item{legend.show}{Logical. Whether the legend should be displayed. Default = \code{TRUE}.}

\item{data.out}{Logical. When set to \code{TRUE}, changes the output, from the plot alone, to a list containing the plot (\code{p}), its underlying data (\code{data}),
and the ultimately used mapping of columns to given aesthetic sets, because modification of newly made columns is required for many features ("cols_used").}

\item{numeric.only}{Logical. Whether the function should error if data given by \code{vars} is not numeric.}
}
\value{
a ggplot object where dots of different colors and sizes summarize continuous data for multiple features (columns) per multiple groups (rows)

Alternatively when \code{data.out = TRUE}, a list containing the plot ("p") and the underlying data as a dataframe ("data").

Alternatively when \code{do.hover = TRUE}, a plotly converted version of the plot where additional data will be displayed when the cursor is hovered over the dots.
}
\description{
Compact plotting of per group summaries for expression of multiple features
}
\details{
This function outputs a compact dual-value summarization, per group, of multiple attributes,
where dot-size and dot-color are used to reflect these dual-values.

Internally, the data for each element of \code{vars} is obtained.
Then, \code{var.adjustment} and \code{var.adj.fxn} determine if and how the data might be adjusted \emph{prior to} summarization and \code{rows.use}-subsetting.
Groupings are determined using \code{group.by}, and then data for each variable is summarized based on \code{summary.fxn.color} & \code{summary.fxn.size}.

If \code{scale = TRUE} (default setting), the color summary values are then centered and scaled.
Doing so 1) puts values for all \code{vars} in a similar range, and 2) emphasizes relative differences between groups.

Note: It can be good to look at both scaled and un-scaled versions because this emphasis of differences between groups can be both good and bad.
Tiny differences within an attribute with a small standard deviation across groups can be made to appear drastic, visually, in the scaled version.
E.g. summarized color data of 2.01 versus 2.02, where summary values for that \code{var} all fell between this small [2.01,2.02] range, will appear quite drastic!)

Finally, data is plotted as dots of differing colors and sizes.
}
\section{Many characteristics of the plot can be adjusted using discrete inputs}{

\itemize{
\item Size of the dots can be changed with \code{size}.
\item Subsetting to utilize only certain observations can be achieved with \code{rows.use}.
\item Colors can be adjusted with \code{min.color} and \code{max.color}.
\item Displayed value ranges can be adjusted with \code{min.value.color} and \code{max.value.color} for color, or \code{min.size} and \code{max.size} for size.
\item Titles and axes labels can be adjusted with \code{main}, \code{sub}, \code{xlab}, \code{ylab}, \code{legend.color.title}, and \code{legend.size.title} arguments.
\item The legend can be hidden by setting \code{legend.show = FALSE}.
\item The color legend tick marks and associated labels can be adjusted with \code{legend.color.breaks} and \code{legend.color.breaks.labels}, respectively.
\item The groupings labels and order can be changed using \code{y.labels} and \code{y.reorder}
\item Rotation of x-axis labels can be turned off with \code{x.labels.rotate = FALSE}.
}
}

\examples{
example("dittoExampleData", echo = FALSE)

### For now, modeling this example around the way dotPlots are used for
# single-cell cluster expression summarization, but plan will be to expand to
# additionally include summary of effect sizes + pvals.

# These random data aren't very exciting, but we can at least add some zeros
#   for making slightly more interesting dot plots.
example_df[1:40, paste0("gene", 1:3)] <- 0

dotPlotCalc(
    example_df, c("gene1", "gene2", "gene3", "gene4"),
    group.by = "clustering")

# 'summary.fxn.color' determines how var-data are summarized per group for the
#   color/fill based visual representation.
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    summary.fxn.color = function(x) { mean(x[x!=0]) },
    legend.color.title = "Average\nExpression\n(when captured)")

# 'summary.fxn.size' determines how var-data are summarized per group for the
#   dot-size based visual representation.
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    summary.fxn.color = function(x) { mean(x[x!=0]) },
    legend.color.title = "Average\nExpression\n(when expressed)",
    summary.fxn.size = function(x) { sum(x!=0)/length(x) * 100 },
    legend.size.title = "Percent\nExpression")

# 'size' adjusts the dot-size associated with the highest percent expression
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    size = 12)

# 'scale' input can be used to control / turn off scaling of avg exp values.
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    scale = FALSE)

# x-axis label rotation can be controlled with 'x.labels.rotate'
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    x.labels.rotate = FALSE)

# Title are adjustable via various discrete inputs:
dotPlotCalc(example_df, c("gene1", "gene2", "gene3", "gene4"), "clustering",
    main = "Title",
    sub = "Subtitle",
    ylab = "y-axis label",
    xlab = "x-axis label",
    legend.color.title = "Colors title",
    legend.size.title = "Dot size title")

}
\seealso{
\code{\link{yPlot}} for plotting of individual \code{var}s where each makes up a separate plot or (set of) facet(s).
}
\author{
Daniel Bunis
}
