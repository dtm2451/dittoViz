% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/freqPlot.R
\name{freq_stats}
\alias{freq_stats}
\title{Calculate per-sample frequencies of clusters or cell annotations, and compare them across group.}
\usage{
freq_stats(
  data_frame,
  freq.by,
  sample.by,
  group.by,
  group.1,
  group.2,
  freq.targs = NULL,
  rows.use = NULL,
  wilcox.adjust = list(),
  do.adjust = TRUE,
  p.adjust.method = "fdr",
  do.fc = TRUE,
  fc.pseudocount = 0,
  comp.data.out = FALSE,
  data.direct = FALSE
)
}
\arguments{
\item{data_frame}{A data_frame where columns are features and rows are observations you might wish to visualize.}

\item{freq.by}{Single string representing the name of a column of \code{data_frame} that contains the cluster or cell identities to quantify and assess.}

\item{sample.by}{Single string representing the name of a column of \code{data_frame} that denotes which sample each observation belongs to.}

\item{group.by}{Single string representing the name of a column of \code{data_frame} that contains group identities.}

\item{group.1, group.2}{Single strings naming the 2 sets of \code{group.by}-data to compare.}

\item{freq.targs}{Single string or a string vector naming which cell/cluster/\code{freq.by}-data identities to target.
When not provided, the function will loop through all identities in the \code{freq.by} column.}

\item{rows.use}{String vector of rownames of \code{data_frame} OR an integer vector specifying the row-indices of data points which should be plotted.

Alternatively, a Logical vector, the same length as the number of rows in \code{data_frame}, where \code{TRUE} values indicate which rows to plot.}

\item{wilcox.adjust}{named list providing any desired additional inputs for the p-value calculation with \code{\link[stats]{wilcox.test}}.
\code{x} and \code{y} inputs are filled in by this function, but all others can be adjusted if desired.}

\item{do.adjust}{Logical stating whether to perform p-value adjustment per multiple hypothesis testing.
Highly recommended, but if you are performing multiple iterations of this function,
proper correction requires running this correction once on all p-values.
See \code{\link[stats]{p.adjust}}.}

\item{p.adjust.method}{String, "fdr" by default, passed along to the \code{method} input of \code{\link[stats]{p.adjust}}, any valid option for that input will work.}

\item{do.fc}{Logical stating whether to calculate \code{group.1} and \code{group.2} medians and the fold-changes between them.}

\item{fc.pseudocount}{Number, zero by default. A value to add within fold_change calculations only, to both \code{group.1} and \code{group.2} median frequencies in order to avoid division by zero errors.
When needed, we recommend something small relative to the lowest expected cell frequencies of the data, 0.000001 perhaps.
Although a relatively small value like this can lead to heavily inflated log fold change values in the extreme cases where \code{group.1} or \code{group.2} frequencies are 0 or near 0, a tiny pseudocount leaves all other fold change values only minimally affected.}

\item{comp.data.out}{Logical. When set to \code{TRUE}, changes the output from the stats data.frame alone to a named list containing both the stats ("stats") and the underlying per-sample frequency calculations ("data").}

\item{data.direct}{Logical, primarily for internal use. Tells the function that the provided \code{data_frame} is already the output of dittoViz's composition calculation, so that does not need to be re-run.}
}
\value{
a data.frame. Or if \code{data.out} was set to \code{TRUE}, a named list containing 2 data.frames: \itemize{
\item 'stats' = the standard output
\item 'data' = the composition summary statistics are based upon.
}
}
\description{
Calculate per-sample frequencies of clusters or cell annotations, and compare them across group.
}
\details{
The function starts by utilizing the same code behind \code{\link{freqPlot}} and \code{\link{barPlot}} composition calculations for
\code{freq.by}-identity frequency calculation within \code{sample.by}-samples.
Observations are first trimmed based on any given \code{rows.use} selection,
then frequencies are calculated and percent normalized,
and which \code{sample.by}-samples belong to which \code{group.by}-groups are marked.
(Set \code{comp.data.out = TRUE} to output this composition data.frame as well!)

Afterwards, it loops through all \code{freq.targs}, building a row of the eventual stats return for each.
P values are calculated viz the \code{\link[stats]{wilcox.test}} function.

If \code{do.fc} is left as \code{TRUE}, group medians and fold change between them are calculated.
Of note, a \code{pseudocount} can be introduced in median fold change calculation to prevent errors from division by zero. The use of a \code{pseudocount} has no effect on p-values.

If \code{do.adjust} is left as \code{TRUE}, p-values will be adjusted based on the \code{p.adjust.method} which default to the false discovery rate method.
}
\section{The stats data.frame return}{

Each row holds statistics for an individual comparison.
The columns represent:
\itemize{
\item Y: cell/cluster/\code{freq.by}-data identity
\item group1: \code{group.1},
(for compatibility with running the function multiple times, each targeting distinct groups, and then concatenating all outputs together!)
\item group2: \code{group.2}, "
\item max_freq: The maximum frequency of either group, which can be helpful to know for plotting purposes
\item p: The p-value associated with comparison of percent frequencies of group.1 samples versus group.2 samples using a Mann Whitney U Test / wilcoxon rank sum test (\code{\link[stats]{wilcox.test}}).
\item padj (\code{do.adjust = TRUE}): p-values corrected by the chosen \code{p.adjust.method}, FDR by default, built from running \code{p.adjust(stats$p, method = p.adjust.method)} per all hypotheses tested in this call to the \code{freq_stats} function.
\item median_g1 (\code{do.fc = TRUE}): the median frequency within samples from \code{group.1}
\item median_g2 (\code{do.fc = TRUE}): the median frequency within samples from \code{group.2}
\item median_fold_change (\code{do.fc = TRUE}): \code{(median_g1 + pseudocount) / (median_g2 + pseudocount)}.
\item median_log2_fold_change (\code{do.fc = TRUE}): \code{log2(median_fold_change)}
\item positive_fc_means_up_in (\code{do.fc = TRUE}): Always \code{group.1}. A minor note to help remember the directionality of these fold changes!
}
}

\author{
Daniel Bunis
}
